From 3552ac862497bdb5ea73639851bbfd114b795fa2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Thu, 11 Mar 2021 20:41:36 +0100
Subject: [PATCH] Revert "sd-event: make use of epoll_pwait2() for greater time
 accuracy"

This reverts commit 798445ab84cff51bde7fcf936f0fb19c37cf858c.

Unfortunately this causes test-event to hang. 32 bit architectures seem
affected: i686 and arm32 in fedora koji. 32 bit build of test-event hangs
reliably under valgrind:

$ PKG_CONFIG_LIBDIR=/usr/lib/pkgconfig meson build-32 -Dc_args=-m32 -Dc_link_args=-m32 -Dcpp_args=-m32 -Dcpp_link_args=-m32 && ninja -C build-32 test-event && valgrind build/test-event
---
 src/libsystemd/sd-event/sd-event.c | 73 ++++++------------------------
 1 file changed, 14 insertions(+), 59 deletions(-)

diff --git a/src/libsystemd/sd-event/sd-event.c b/src/libsystemd/sd-event/sd-event.c
index 8ab9d419af..69d9c5e780 100644
--- a/src/libsystemd/sd-event/sd-event.c
+++ b/src/libsystemd/sd-event/sd-event.c
@@ -3781,59 +3781,9 @@ pending:
         return r;
 }
 
-static int epoll_wait_usec(
-                int fd,
-                struct epoll_event *events,
-                int maxevents,
-                usec_t timeout) {
-
-        static bool epoll_pwait2_absent = false;
-        int r, msec;
-
-        /* A wrapper that uses epoll_pwait2() if available, and falls back to epoll_wait() if not */
-
-        if (!epoll_pwait2_absent && timeout != USEC_INFINITY) {
-                struct timespec ts;
-
-                r = epoll_pwait2(fd,
-                                 events,
-                                 maxevents,
-                                 timespec_store(&ts, timeout),
-                                 NULL);
-                if (r >= 0)
-                        return r;
-                if (!ERRNO_IS_NOT_SUPPORTED(r) && !ERRNO_IS_PRIVILEGE(r))
-                        return -errno; /* Only fallback to old epoll_wait() if the syscall is masked or not
-                                        * supported. */
-
-                epoll_pwait2_absent = true;
-        }
-
-        if (timeout == USEC_INFINITY)
-                msec = -1;
-        else {
-                usec_t k;
-
-                k = DIV_ROUND_UP(timeout, USEC_PER_MSEC);
-                if (k >= INT_MAX)
-                        msec = INT_MAX; /* Saturate */
-                else
-                        msec = (int) k;
-        }
-
-        r = epoll_wait(fd,
-                       events,
-                       maxevents,
-                       msec);
-        if (r < 0)
-                return -errno;
-
-        return r;
-}
-
 _public_ int sd_event_wait(sd_event *e, uint64_t timeout) {
         size_t n_event_queue, m;
-        int r;
+        int r, msec;
 
         assert_return(e, -EINVAL);
         assert_return(e = event_resolve(e), -ENOPKG);
@@ -3852,16 +3802,21 @@ _public_ int sd_event_wait(sd_event *e, uint64_t timeout) {
 
         /* If we still have inotify data buffered, then query the other fds, but don't wait on it */
         if (e->inotify_data_buffered)
-                timeout = 0;
+                msec = 0;
+        else
+                msec = timeout == (uint64_t) -1 ? -1 : (int) DIV_ROUND_UP(timeout, USEC_PER_MSEC);
 
         for (;;) {
-                r = epoll_wait_usec(e->epoll_fd, e->event_queue, e->event_queue_allocated, timeout);
-                if (r == -EINTR) {
-                        e->state = SD_EVENT_PENDING;
-                        return 1;
-                }
-                if (r < 0)
+                r = epoll_wait(e->epoll_fd, e->event_queue, e->event_queue_allocated, msec);
+                if (r < 0) {
+                        if (errno == EINTR) {
+                                e->state = SD_EVENT_PENDING;
+                                return 1;
+                        }
+
+                        r = -errno;
                         goto finish;
+                }
 
                 m = (size_t) r;
 
@@ -3874,7 +3829,7 @@ _public_ int sd_event_wait(sd_event *e, uint64_t timeout) {
                 if (!GREEDY_REALLOC(e->event_queue, e->event_queue_allocated, e->event_queue_allocated + n_event_queue))
                         return -ENOMEM;
 
-                timeout = 0;
+                msec = 0;
         }
 
         triple_timestamp_get(&e->timestamp);
-- 
2.30.1

